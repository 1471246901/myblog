# 静态代理和动态代理的区别，什么场景使用？

**代理模式**

代理模式（Proxy Pattern），又叫委托模式，是指为其他对象提供一种代理，以控制对这个对象的访问，属于结构型设计模式
目的是为了保护目标对象或增强目标对象

抽象角色-Subject：可以是抽象类，也可以是接口
真实角色/委托类-RealSubject：业务逻辑的具体执行者
代理角色/代理类-Proxy：把所有抽象主题角色定义的方法限制委托给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理

隐藏委托类，在一定程度上实现了解耦合，同时提高了安全性，符合开闭原则（扩展开放、修改封闭）

## 静态代理

显示声明代理对象，在编译期就生成了代理类
由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行之前，代理类的类文件就已经被创建了

实现：一个公共接口、一个委托类、一个代理类
优点：简单、实用、效率高
缺点：
需要实现接口，造成代码冗余
只能对固定接口的实现类实现代理，灵活性较差

## 动态代理

在程序运行时通过反射机制动态创建代理类
优点：只需将被委托类作为参数传入即可，使用灵活；服务内容只需写在invoke方法中，减少了代码冗余
缺点：效率较低

基于JDK实现：通过JDK提供的工具方法Proxy.newProxyInstance动态构建全新的代理类（继承Proxy类，并持有InvocationHandler接口引用）字节码文件并实例化对象返回。由Java内部的反射机制来实例化代理对象，并代理的调用委托类方法

基于CGlib实现：基于继承被代理类生成代理子类，不用实现接口，只需被代理类为非final类，底层借用ASM字节码技术实现

基于AspectJ实现：修改目标类的字节，织入代理的字节，在程序编译的时候，插入动态代理的字节码，不会生成全新的class

基于Instrumentation实现：修改目标类的字节码，类装载的时候动态拦截，插入动态代理的字节码，不会生成全新的class，基于JavaAgent